/***************************************************
 *                                                 *
 *              Sketch framework code              *
 *                                                 *
 ***************************************************/

// JS reference.
JavaScript javascript = null;

/**
 * Bind JS reference.
 */
void bindJavaScript(JavaScript js) {
  javascript = js;
}

// constants
final Point ORIGIN = new Point(0,0);

// quasi-universal sketch dimensions
final int dim = 300;
final int pad = 20;

/**
  Generic main sketch code. All the important bits happen in whatever supplies drawFunction()
**/
BezierComputer comp = new BezierComputer();
BezierComputer getComputer() { return comp; }

ArrayList<BezierCurve> curves = new ArrayList<BezierCurve>();
PolyBezierCurve p = new PolyBezierCurve();
ArrayList<BezierCurve> getCurves() { return curves; }

float t = 0, step = 0.002;

/**
 * set up a curve, and show everything we know about it.
 */
void setup() {
  ellipseMode(CENTER);
  // force text engine load (only needed for Processing)
  text("",0,0);
  setupColors();
  noLoop();
  reset();
}

// reset all the things
void reset() {
  // reset values
  curves.clear();
  t = 0;
  step = 0.002;
  // reset methods
  setupScreen();
  noAnimate();
  setupCurve();
  noReset();
}

// the default 2nd order curve
void setupDefaultQuadratic() {
  Point[] points = {
    new Point(70,250),
    new Point(20,110),
    new Point(250,60)
  };
  curves.add(new BezierCurve(points));
}

// the default 3rd order curve
void setupDefaultCubic() {
  Point[] points = {
    new Point(120,160),
    new Point(35,200),
    new Point(220,260),
    new Point(220,40)
  };
  curves.add(new BezierCurve(points));
}

// the default 2nd order poly-curve
void setupDefaultQuadraticPoly() {
  p.addCurve(new BezierCurve(new Point[]{
    new Point(1/3.0*dim, 2/3.0*dim),
    new Point(1/6.0*dim, 1/2.0*dim),
    new Point(1/3.0*dim, 1/3.0*dim)
  }));
  p.addCurve(new BezierCurve(new Point[]{ ORIGIN, ORIGIN, new Point(2/3.0*dim,1/3.0*dim) }));
  p.addCurve(new BezierCurve(new Point[]{ ORIGIN, ORIGIN, new Point(2/3.0*dim,2/3.0*dim) }));
}

// the default 3rd order poly-curve
void setupDefaultCubicPoly() {
  int pad = dim/3;
  float k = 0.55228;
  p.addCurve(new BezierCurve(new Point[]{
    new Point(dim/2, dim/2+pad),
    new Point(dim/2 + k*pad, dim/2+pad),
    new Point(dim/2 + pad, dim/2 + k*pad),
    new Point(dim/2 + pad, dim/2)
  }));
  p.addCurve(new BezierCurve(new Point[]{
    ORIGIN,
    ORIGIN,
    new Point(dim/2 + k*pad, dim/2-pad),
    new Point(dim/2, dim/2-pad)
  }));
  p.addCurve(new BezierCurve(new Point[]{
    ORIGIN,
    ORIGIN,
    new Point(dim/2-pad, dim/2-k*pad),
    new Point(dim/2-pad, dim/2)
  }));
}



int panelDim = dim;

/**
 * pad the sketch translation
 */
void usePanelPadding() {
  translate(pad, pad);
  panelDim = dim - 2*pad;
}

/**
 * switch drawing over to the next dim*dim area
 */
void nextPanel() {
  translate(dim,0);
}

// draws a set of labeled axes
void drawAxes(String horizontalLabel, float hs, float he, String verticalLabel, float vs, float ve) {
  pushStyle();
  stroke(0);
  line(0,0,panelDim,0);
  line(0,0,0,panelDim);
  fill(0);
  // horizontal
  textAlign(CENTER);
  text(horizontalLabel + " →",panelDim/2,-8);
  textAlign(LEFT);
  hs = int(1000*hs)/1000;
  text(""+hs,0,-2);
  textAlign(RIGHT);
  he = int(1000*he)/1000;
  text(""+he,panelDim,-2);
  // vertical
  textAlign(RIGHT);
  text(verticalLabel + "\n↓",-8,panelDim/2);
  textAlign(RIGHT,TOP);
  vs = int(1000*vs)/1000;
  text(""+vs,-2,0);
  textAlign(RIGHT,BOTTOM);
  ve = int(1000*ve)/1000;
  text(""+ve,-2,panelDim);
  // clear
  popStyle();
}

/**
 * Draw a bounding box
 */
void drawBoundingBox(Point[] p) {
  if(p==null) return;
  pushStyle();
  stroke(0,255,0);
  line(p[0].x,p[0].y,p[1].x,p[1].y);
  line(p[1].x,p[1].y,p[2].x,p[2].y);
  line(p[2].x,p[2].y,p[3].x,p[3].y);
  line(p[3].x,p[3].y,p[0].x,p[0].y);
  popStyle();
}

// draw all the spanlines generated by a curve
void drawSpan(BezierCurve curve, float t) {
  Point[] span = curve.generateSpan(t);
  int order = curve.order;
  if(!showSpan) return;
  int next = order+1;
  for(int c = order; c>0; c--) {
    stroke(0,map(c,1,order,255,0),map(c,1,order,0,255));
    for(int i = 0; i<c; i++) {
      line(span[next-c-1].x, span[next-c-1].y, span[next-c].x, span[next-c].y);
      ellipse(span[next-c-1].x, span[next-c-1].y, 3, 3);
      ellipse(span[next-c].x, span[next-c].y, 3, 3);
      next++;
    }
  };
}

/**
 * Pass-through that takes care of [t] incrementing
 */
void draw() {
  if(ghosting && frameCount>1) {
    strokeWeight(0);
    fill(255,10);
    rect(-1,-1,width+1,height+1);
    strokeWeight(1);
  } else { background(255); }
  if(playing) { preDraw(); }
  drawFunction();
  if(playing) { postDraw(); }

  // PJS patching
  resetMatrix();

  if(animated && !playing) {
    pushStyle();
    fill(255,0,0,25);
    textAlign(CENTER,CENTER);
    textSize(dim/9);
    text("Animated sketch\nCick to play/pause", width/2, height/2);
    popStyle();
  }
}

/**
 * Fixed color list
 */
int[] colorListing = new int[100];

void setupColors() {
  for(int i=0; i<colorListing.length; i++) {
    randomSeed(i);
    colorListing[i] = color(random(255),random(255),random(255));
  }
}

int getColor(float idx) { return colorListing[int(idx) % 100]; }

