<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Bézier curve framework</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <a class="ribbon" href="http://github.com/pomax/bezierinfo"><img
      src="images/ribbon.png"
      alt="check the code on GitHub"
      title="check out the code on GitHub"
    ></a>

    <header>
        <h1>A Primer on Bézier Curves</h1>
    </header>

    <section id="preface">
      <div id="navbar">
        <h3>Table of Contents</h3>
      </div>

      <p>This page houses the new codepase and example sketches while the
      <a href="http://processingjs.nihongoresources.com/Bézierinfo/">original article</a> is reworked
      to incorporate them, with text rewrites where necessary to explain things better.</p>

      <h2 style="font-style:italic;">All Bézier graphics are interactive</h2>

      <p>This page uses <a href="http://processing.org">Processing</a> examples, rendering as
      interactive graphics on the page using <a href="http://processingjs.org">Processing.js</a>,
      which means you don't need any plugins if you're on a modern browser. (If you
      are still using IE8 because you're on Windows XP, be aware Microsoft would rather you start
      using something like Firefox than keep using IE8, because IE8 does not support the internet
      anymore. It was already a little behind when it was first released, but today it literally
      doesn't support the internet, a bit like how notepad can't open word documents. It's no longer
      a web browser, it's a legacy application). It also uses math, in LaTeX form, which is typeset
      using the most excellent <a href="http://mathjax.org">MathJax</a> library.</p>

      <h2 style="font-style:italic;">Examples have a "view source" option</h2>

      <p>Just seeing that the guy who wrote the article knows how to write the code needed to
      demonstrate Bezier curve things is basically useless, I think you'll agree. You don't benefit
      from me going: <em>"Look at me, I know how to program, ooooh~"</em>. So to make things <em>useful</em>,
      all graphics on this page have "view source" links. Click them, copy the source code, fire
      up the Processing PDE, paste the code, and hit "play". You should see the exact same thing
      now running on your own computer as you're seeing in the browser. This is working code,
      and you can trace everything I do. Regardless of whether you <em>want</em> to, I consider
      it important that you can. And the kicker is this code is in the public domain. I waive
      all rights to it. Do with it what you want, to me this is trivial code and it would be
      ridiculous to claim it as anything other than "I just wrote this to demonstrate how things
      work".</p>

      <h2 style="font-style:italic;">Questions, comments</h2>

      If you have suggestions for new sections, hit up the github issue tracker (linked to in the upper
      right). If you have questions about the material, there's currently no comment section while I'm
      doing the rewrite, but you can use the issue tracker for that as well. Once the rewrite's done,
      I'll add a general comment section back in, and maybe a more topical "select this section of text
      and hit the 'question' button to ask a question about it" system. We'll see.

      <p>—Pomax (or in the tweetworld, @<a href="https://twitter.com/TheRealPomax">TheRealPomax</a>)</p>
    </section>

    <section id="introduction">
      <h2>Introduction</h2>

      <p>Let's start with the good stuff: when we're talking about Bézier curves, we're talking about the
      things that you can see in the following graphics. They run from some start point to some end point,
      with their curvature influenced by one or more "intermediate" control points. Now, because all the
      graphics on this page are interactive, go manipulate those curves a bit: click-drag the points,
      and see how their shape changes based on what you do.</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Quadratic Bézier curves">
      void setupCurve() {
        setupDefaultQuadratic();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();
      }</textarea>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Cubic Bézier curves">
      void setupCurve() {
        setupDefaultCubic();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();
      }</textarea>

      <p>These curves are used a lot in computer aided design and computer aided manufacturing (CAD/CAM)
      applications, as well as in graphic design programs like Adobe Illustrator and Photoshop, Inkscape,
      the Gimp, etc. and in graphic technologies like scalable vector graphics (SVG) and OpenType fonts
      (ttf/otf). A lot of things use Bézier curves, so if you want to learn more about them... prepare
      to get your learn on!</p>
    </section>

    <section id="explanation">
      <h2>So how do they work?</h2>

      <p>Bézier curves are a form of "parametric" function. Mathematically speaking, parametric
      functions are cheats: a "function" is actually a well defined term representing a mapping
      from any number of inputs to a <strong>single</strong> output. Numbers go in, a single
      number comes out. Change the numbers that go in, and the number that comes out is still
      a single number. Parametric functions cheat. They basically say "alright, well, we want
      multiple values coming out, so we'll just use more than one function". An illustration:
      Let's say we have a function that maps some value, let's call it <i>x</i>, to
      some other value, using some kind of number manipulation:</p>

      <p>\[
        f(x) = \sin(x)
      \]</p>

      <p>The notation <i>f(x)</i> is the standard way to show that it's a function (by convention
      called <i>f</i> if we're only listing one) and its output changes based on one variable
      (in this case, <i>x</i>). Change <i>x</i>, and the output for <i>f(x)</i> changes.</p>

      <p>So far so good. Now, let's look at parametric functions, and how they cheat.
      Let's take the following two functions:</p>

      <p>\[\begin{matrix}
        f(a) = \sin(a) \\
        f(b) = \cos(b)
      \end{matrix}\]</p>

      <p>There's nothing really remarkable about them, they're just a sine and cosine function,
      but you'll notice the inputs have different names. If we change the value for <i>a</i>,
      we're not going to change the output value for <i>f(b)</i>, since <i>a</i> isn't used
      in that function. Parametric functions cheat by changing that. In a parametric function
      all the different functions share a variable, like this:</p>

      <p>\[
      \left \{ \begin{matrix}
        f_a(t) = \sin(t) \\
        f_b(t) = \cos(t)
      \end{matrix} \right. \]</p>

      <p>Multiple functions, but only one variable. If we change the value for <i>t</i>,
      we change the outcome of both <i>f<sub>a</sub>(t)</i> and <i>f<sub>b</sub>(t)</i>.
      You might wonder how that's useful, and the answer is actually prety simple: if
      we change the labels <i>f<sub>a</sub>(t)</i> and <i>f<sub>b</sub>(t)</i> with what
      we usually mean with them for parametric curves, things might be a lot more obvious:</p>

      <p>\[
      \left \{ \begin{matrix}
        x = \sin(t) \\
        y = \cos(t)
      \end{matrix} \right. \]</p>

      <p>There we go. <i>x</i>/<i>y</i> coordinates, linked through some mystery value <i>t</i>.</p>

      <p>So, parametric curves don't define a <i>y</i> coordinate in terms of an <i>x</i> coordinate,
      like normal functions do, but they instead link the values to a "control" variable.
      If we vary the value of <i>t</i>, then with every change we get <strong>two</strong> values,
      which we can use as (<i>x</i>,<i>y</i>) coordinates in a graph. The above set of functions,
      for instance, generates points on a circle: We can range <i>t</i> from negative to positive
      infinity, and the resulting (<i>x</i>,<i>y</i>) coordinates will always lie on a circle with
      radius 1 around the origin (0,0). If we plot it for <i>t</i> from 0 to 5, we get this:</p>

      <textarea class="sketch-code" data-sketch-preset="empty" data-sketch-title="A circle: x=sin(t), y=cos(t)">

      void drawFunction() {
        translate(dim/2,dim/2);
        stroke(150);
        line(-dim,0,dim,0);
        line(0,-dim,0,dim);

        stroke(0);
        float r = dim/3;
        for(float t=0; t<=5; t+=0.01) {
          point(r * sin(t), r * cos(t));
        }

        fill(0);
        for(float i=0; i<=5; i+=0.5) {
          ellipse(r*sin(i),r*cos(i),3,3);
          text("t="+i,r*sin(i)+10,r*cos(i));
        }

        fill(150);
        textAlign(CENTER,CENTER);
        text("0,0",-10,10);
        text("1",r+10,15);
        text("-1",-10,r+10);
        text("-1",-r-10,15);
        text("1",-10,-r-10);
      }</textarea>

      <p>Bézier curves are (one in many classes of) parametric functions, and are characterised
      by using the same base function for all its dimensions. Unlike the above example,
      where the <i>x</i> and <i>y</i> values use different functions (one uses a sine, the other
      a cosine), Bézier curves use the "binomial polynomial" for both <i>x</i> and <i>y</i>.
      So what are binomial polynomials?</p>

      <p>You may remember polynomials from high school, where they're those sums that look like:</p>

      <p>\[
        f(x) = a \cdot x^3 + b \cdot x^2 + c \cdot x + d
      \]</p>

      <p>If they have a highest order term <i>x³</i> they're called "cubic" polynomials, if it's
      <i>x²</i> it's a "square" polynomial, if it's just <i>x</i> it's a line (and if there aren't
      even any terms with <i>x</i> it's not a polynomial!)</p>

      <p>Bézier curves are polynomials of <i>t</i>, rather than <i>x</i>, with the value for <i>t</i>
      fixed being between 0 and 1, with coefficients <i>a</i>, <i>b</i> etc. taking the "binomial"
      form, which sounds fancy but is actually a pretty simple description for mixing values:</p>

      <p>\[ \begin{align*}
        linear &= (1-t) + t \\
        square &= (1-t)^2 + 2 \cdot (1-t) \cdot t + t^2 \\
        cubic &= (1-t)^3 + 3 \cdot (1-t)^2 \cdot t + 3 \cdot (1-t) \cdot t^2 + t^3
      \end{align*} \]</p>

      <p>I know what you're thinking: that doesn't look too simple, but if we remove <i>t</i> and
      add in "times one", things suddenly look pretty easy. Check out these binomial terms:</p>

      <p>\[ \begin{align*}
        linear &= \hskip{2.5em} 1 + 1 \\
        square &= \hskip{1.7em} 1 + 2 + 1\\
        cubic &= \hskip{0.85em} 1 + 3 + 3 + 1\\
        hypercubic &= 1 + 4 + 6 + 4 + 1
      \end{align*} \]</p>

      <p>Notice that 2 is the same as 1+1, and 3 is 2+1 and 1+2, and 6 is 3+3... As you
      can see, each time we go up a dimension, we simply start and end with 1, and everything
      in between is just "the two numbers above it, added together". Now <i>that's</i> easy
      to remember.</p>

      <p>There's an equally simple way to figure out how the polynomial terms work:
      if we rename <i>(1-t)</i> to <i>a</i> and <i>t</i> to <i>b</i>, and remove the weights
      for a moment, we get this:</p>

      <p>\[ \begin{align*}
        linear &= a + b \\
        square &= a \cdot a + a \cdot b + b \cdot b \\
        cubic &= a \cdot a \cdot a + a \cdot a \cdot b + a \cdot b \cdot b + b \cdot b \cdot b\\
      \end{align*} \]</p>

      <p>It's basically just a sum of "every combination of <i>a</i> and <i>b</i>", progressively
      replacing <i>a</i>'s with <i>b</i>'s after every + sign. So that's actually pretty simple
      too. So now you know binomial polynomials, and just for completeness I'm going to show
      you the generic function for this:</p>

      <p>\[
        Bézier(n,t) = \sum_{i=0}^{n}
                      \underset{binomial\ term}{\underbrace{\binom{n}{i}}}
                      \cdot\
                      \underset{polynomial\ term}{\underbrace{(1-t)^{n-i} \cdot t^{i}}}
      \]</p>

      <p>And that's the full description for Bézier curves. Σ in this function indicates that this is
      a series of additions (using the variable listed below the Σ, starting at ...=<value> and ending
      at the value listed on top of the Σ). So, now we know what the base function(s) look(s) like,
      time to add in the magic that makes Bézier curves so special: control points.<p>

      <h2>Controlling Bézier curvatures</h2>

      <p>Bézier curves are (like all "splines") interpolation funtions, meaning they take a set of
      points, and generate values somewhere "between" those points. (One of the consequences of this
      is that you'll never be able to generate a point that lies outside the outline for the control
      points, commonly called the "hull" for the curve. Useful information!). In fact, we can visualise
      how each point contributes to the value generated by the function, so we can see which points are
      important, where, in the curve.</p>

      <p>The following graphs show the interpolation functions for quadratic and cubic curves, with "S"
      being the strength of a point's contribution to the total sum of the Bézier function. Click or
      click-drag to see the interpolation percentages for each curve-defining point at a specific <i>t</i>
      value.</p>

      <p>Also shown is the interpolation function for a 15th order Bézier function. As you can see,
      the start and end point contribute considerably more to the curve's shape than any other point
      in the control point set.</p>

      <textarea class="sketch-code" data-sketch-preset="ratios" data-sketch-title="Quadratic interpolations">
      int order = 3;
      </textarea>

      <textarea class="sketch-code" data-sketch-preset="ratios" data-sketch-title="Cubic interpolations">
      int order = 4;
      </textarea>

      <textarea class="sketch-code" data-sketch-preset="ratios" data-sketch-title="15th order interpolations">
      int order = 15;
      </textarea>

      <p>If we want to change the curve, we need to change the weights of each point, effectively changing
      the interpolations. The way to do this is about as straight forward as possible: just multiply each
      point with a value that changes its strength. These values are conventionally called "Weights", and
      we can add them to our original Bézier function:</p>

      <p>\[
        Bézier(n,t) = \sum_{i=0}^{n}
                      \underset{binomial\ term}{\underbrace{\binom{n}{i}}}
                      \cdot\
                      \underset{polynomial\ term}{\underbrace{(1-t)^{n-i} \cdot t^{i}}}
                      \cdot\
                      \underset{weight}{\underbrace{w_i}}
      \]</p>

      <p>That looks complicated, but as it so happens, the "weights" are actually just the coordinate values
      we want our curve to have: for an <i>n<sup>th</sup></i> order curve, w<sub>0</sub> is our start coordinate,
      w<sub>n</sub> is our last coordinate, and everything in between is a controlling coordinate. Say we want
      a cubic curve that starts at (120,160), is controlled by (35,200) and (220,260) and ends at (220,40),
      we use this Bézier curve:</p>

      <p>\[
      \left \{ \begin{matrix}
        x = \underline{120} \cdot (1-t)^3 + \underline{35} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{220} \cdot 3 \cdot (1-t) \cdot t^2 + \underline{220} \cdot t^3 \\
        y = \underline{160} \cdot (1-t)^3 + \underline{200} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{260} \cdot 3 \cdot (1-t) \cdot t^2 + \underline{40} \cdot t^3
      \end{matrix} \right. \]</p>

      <p>Which gives us the curve we saw at the top of the article:</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Our cubic Bézier curve">
      void setupCurve() {
        setupDefaultCubic();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();
      }</textarea>

      <p>What else can we do with Bézier curves? Quite a lot, actually. The rest of this article covers
      a multitude of possible operations and algorithms that we can apply, and the tasks they achieve.</p>
    </section>

    <section id="reordering">
      <h2>Lowering and elevating curve order</h2>

      <p>One interesting property of Bézier curves is that an <i>n<sup>th</sup></i> order curve can
      always be perfectly represented by an <i>(n+1)<sup>th</sup></i> order curve, by giving the
      higher order curve specific control points.</p>

      <p>If we have a curve with three points, then we can create a four point curve that exactly
      reproduce the original curve as long as we give it the same start and end points, and for
      its two control points we pick "1/3<sup>rd</sup> start + 2/3<sup>rd</sup> control" and
      "2/3<sup>rd</sup> control + 1/3<sup>rd</sup> end", and now we have exactly the same curve as
      before, except represented as a cubic curve, rather than a quadratic curve.</p>

      <p>The general rule for raising an <i>n<sup>th</sup></i> order curve to an <i>(n+1)<sup>th</sup></i>
      order curve is as follows (observing that the start and end weights are the same as the start and
      end weights for the old curve):</p>

      <p>\[
        Bézier(n+1,t) = \sum_{i=0}^{n+1}
                      \underset{binomial\ term}{\underbrace{\binom{n+1}{i}}}
                      \cdot\
                      \underset{polynomial\ term}{\underbrace{(1-t)^{n+1-i} \cdot t^{i}}}
                      \cdot
                      \underset{new\ weights}{\underbrace{\left ( \frac{i}{n+1} \cdot w_{i-1} + \frac{n+1-i}{n+1} \cdot w_i \right )}}
      \]</p>

      <p>However, this rule also has as direct consequence that you <strong>cannot</strong> generally
      safely lower a curve from <i>n<sup>th</sup></i> order to <i>(n-1)<sup>th</sup></i> order, because
      the control points cannot be "pulled apart" cleanly. We can try to, but the resulting curve will
      not be identical to the original, and may in fact look completely different.</p>

      <p>We can apply this to a (semi) random curve, as is done in the following graphic. Select the sketch
      and press your up and down cursor keys to elevate or lower the curve order.</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="A tenth order Bézier curve">
      void setupCurve() {
        int d = dim - 2*pad;
        int order = 10;
        ArrayList<Point> pts = new ArrayList<Point>();

        float dst = d/2.5, nx, ny, a=0, step = 2*PI/order, r;
        for(a=0; a<2*PI; a+=step) {
          r = random(-dst/4,dst/4);
          pts.add(new Point(d/2 + cos(a) * (r+dst), d/2 + sin(a) * (r+dst)));
          dst -= 1.2;
        }

        Point[] points = new Point[pts.size()];
        for(int p=0,last=points.length; p<last; p++) { points[p] = pts.get(p); }
        curves.add(new BezierCurve(points));
        reorder();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();
      }</textarea>
    </section>

    <section id="components">
      <h2>Component functions</h2>

      <p>One of the first things people run into when they start using Bézier curves in their own programs is
      "I know how to draw the curve, but how do I determine the bounding box?". It's actually reasonably straight
      forward to do so, but it requires having some knowledge on exploiting math to get the values we need.
      For bounding boxes, we aren't actually interested in the curve itself, but only in its "extremities": the minimum
      and maximum values the curve has for its x- and y-axis values. If you remember your calculus (provided you
      ever took calculus, otherwise it's going to be hard to remember) we can determine function extremities using
      the first derivative of that function, but this poses a problem, since our function is parametric: every axis
      has its own function.</p>

      <p>The solution: compute the derivative for each axis separately, and then fit them back together in the same
      way we do for the original.</p>

      <p>Let's look at how a parametric Bézier curve "splits up" into two normal functions, one for the x-axis and
      one for the y-axis. Note the the left-most figure is again an interactive curve, without labeled axes (you
      get coordinates in the graph instead).  The center and right-most figures are the component fuctions for
      computing the x-axis value, given a value for <i>t</i> (between 0 and 1 inclusive), and the y-axis value,
      respectively.</p>

      <p>If you move points in a curve sideways, you should only see the middle graph change; likely, moving
      points vertically should only show a change in the right graph.</p>

      <textarea class="sketch-code" data-sketch-preset="threepanel" data-sketch-title="Quadratic Bézier curve components">
      void setupCurve() {
        setupDefaultQuadratic();
      }

      void drawCurve(BezierCurve curve) {
        additionals();
        curve.draw();

        noAdditionals();
        usePanelPadding();

        nextPanel();
        drawAxes("t",0,1, "x",0,panelDim);
        BezierCurve x_only = curve.justX(dim-2*pad);
        x_only.draw();

        nextPanel();
        drawAxes("t",0,1, "y",0,panelDim);
        BezierCurve y_only = curve.justY(dim-2*pad);
        y_only.draw();
      }</textarea>

      <textarea class="sketch-code" data-sketch-preset="threepanel" data-sketch-title="Cubic Bézier curve components">
      void setupCurve() {
        setupDefaultCubic();
      }

      void drawCurve(BezierCurve curve) {
        additionals();
        curve.draw();

        noAdditionals();
        usePanelPadding();

        nextPanel();
        drawAxes("t",0,1, "x",0,panelDim);
        BezierCurve x_only = curve.justX(dim-2*pad);
        x_only.draw();

        nextPanel();
        drawAxes("t",0,1, "y",0,panelDim);
        BezierCurve y_only = curve.justY(dim-2*pad);
        y_only.draw();
      }</textarea>
    </section>

    <section id="derivatives">
      <h2>Derivatives</h2>

      <p>There's a number of useful things that you can do with Bézier curves based on their derivative,
      and one of the more amusing observations about Bézier curves is that their derivatves are, in fact,
      also Bézier curves. In fact, the derivation of a Bézier curve is relatively straight forward, although
      we do need a bit of math. First, let's revisit our original Bézier curve description:</p>

      <p>\[
        Bézier(n,t) = \sum_{i=0}^{n}
                      \underset{binomial\ term}{\underbrace{\binom{n}{i}}}
                      \cdot\
                      \underset{polynomial\ term}{\underbrace{(1-t)^{n-i} \cdot t^{i}}}
                      \cdot\
                      \underset{weight}{\underbrace{w_i}}
      \]</p>

      <p>And now the function for a curve's derivative:</p>

      <p>\[
        Bézier'(n,t) = \sum_{i=0}^{k}
                      \underset{binomial\ term}{\underbrace{\binom{k}{i}}}
                      \cdot\
                      \underset{polynomial\ term}{\underbrace{(1-t)^{k-i} \cdot t^{i}}}
                      \cdot\
                      \underset{derivative\ weight}{\underbrace{k \cdot (w_{i+1} - w_i)}}
                      {\ },{\ }with{\ }
                      k = (n-1)
      \]</p>


      <p>What are the differences? In terms of the actual Bézier curve, virtually nothing!
      We lowered the order (rather than <i>n</i>, it's now <i>n-1</i>), but it's still the
      same Bézier function. The only real difference, as it turns out, is in how the weights
      change when we derive the curve's function. If we have four points A, B, C, and D, then
      the derivative will have three points, the second derivative two, and the third derivative
      one:</p>

      <p>\[ \begin{array}{l}
        B(n,t),    & n = 4, & w = \{A,B,C,D\} \\
        B'(n,t),   & k = n-1 = 3, & w' = \{A',B',C'\}    &= \{3 \cdot (B-A), {\ } 3 \cdot (C-B), {\ } 3 \cdot (D-C)\} \\
        B''(n,t),  & k = n-2 = 2, & w'' = \{A'',B''\}    &= \{2 \cdot (B'-A'), {\ } 2 \cdot (C'-B')\} \\
        B'''(n,t), & k = n-3 = 1, & w''' = \{A'''\} &= \{1 \cdot (B''-A'')\}
      \end{array} \]</p>

      <p>We can keep performing this trick for as long as we have more than one weight. Once
      we have one weight left, the next step will see <i>k = 0</i>, and the result of our
      "Bézier function" summation is zero, because we're not adding anything at all. As such,
      a quadratic curve has no second derivative, a cubic curve has no third derivative, and
      generalised: an <i>n<sup>th</sup></i> order curve has <i>n-1</i> derivatives.</p>

    </section>

    <section id="extremities">
      <h2>Finding extremities</h2>

      <p>Now that we understand (well, superficially anyway) the component functions, we can find the extremities of our
      Bézier curve by finding maxima and minima on the component functions, by solving the equasions B'(t) = 0 and B''(t) = 0.
      Although, in the case of quadratic curves there is no B''(t), so we only need to compute B'(t) = 0.</p>

      <p>The problem with this is that as the order of the curve goes up, we can't actually solve those equasions the normal
      way. We can't take the function, and then work out what the solutions are. Not to mention that even solving a third
      order derivative (for a fourth order curve) is already a royal pain in the backside. We need a better solution. We
      need numerical approaches.</p>

      <p>That's a fancy word for saying "rather than solve the function, treat the problem as a sequence of identical
      operations, the performing of which gets us closer and closer to the real answer". Finding solutions to any
      <i>f(t) = 0</i> is called "root finding", and there is a really nice numerical root finding algorithm, called
      the Newton-Raphson root finding method (yes, after <strong>that</strong> Newton).</p>

      <div class="note">
        <h2><a href="http://en.wikipedia.org/wiki/Newton-Raphson">Newton-Raphson</a> root finding</h2>

        <p>The Newton-Raphson approach consists of picking a value <i>t</i> (any will do), and getting the corresponding
        value at that <i>t</i> value. For normal functions, we can treat that value as a height. If the height is zero,
        we're done, we have found a root. If it's not, we take the tangent of the curve at that point, and extend
        it until it passes the x-axis, which will be at some new point <i>t</i>. We then repeat the procedure with this
        new value, and we keep doing this until we find our root.</p>

        <p>Mathematically, this means that for some <i>t</i>, at step <i>n=1</i>, we perform the following calculation
        until <i>f<sub>y</sub></i>(<i>t</i>) is zero, so that the next <i>t</i> is the same as the one we already have:</p>

        <p>\[
          t_{n+1} = t_n - \frac{f_y(t_n)}{f'_y(t_n)}
        \]</p>

        <p>(The wikipedia article has a decent animation for this process, so I'm not adding a sketch for that here)</p>

        <p>Now, this works well only if we can pick good starting points, and our curve is continuously differentiable
        and doesn't have oscillations. Glossing over the exact meaning of those terms, the curves we're dealing with
        conform to those constraints, so as long as we pick good starting points, this will work. So the question is:
        which starting points do we pick?</p>

        <p>As it turns out, Newton-Raphson is so blindingly fast, we don't really have to pick: we simply run the
        algorithm from <i>t=0</i> to <i>t=1</i> at small steps (say, 1/200<sup>th</sup>) and the result will be
        all the roots we want. Of course, this may pose problems for high order Bézier curves: 200 steps for a
        200<sup>th</sup> order Bézier curve is going to go wrong, but that's okay: there is no reason, ever, to
        use Bézier curves of orders higher than 10, let alone 100.</p>
      </div>

      <p>With this, we can determine the first and second derivative roots for our Bézier curves, and show them
      in our previous graphics:</p>

      <textarea class="sketch-code" data-sketch-preset="threepanel" data-sketch-title="Quadratic Bézier curve components">
      void setupCurve() {
        setupDefaultQuadratic();
      }

      void drawCurve(BezierCurve curve) {
        additionals();
        curve.draw();

        noAdditionals();
        usePanelPadding();

        nextPanel();
        drawAxes("t",0,1, "x",0,panelDim);
        BezierCurve x_only = curve.justX(dim-2*pad);
        x_only.draw();

        stroke(255,0,0);
        float[] tx = x_only.getInflections();
        for(float t: tx) {
          if(t==0 || t==1) continue;
          Point p = x_only.getPoint(t);
          ellipse(p.x,p.y,5,5);
          line(p.x,p.y-3,p.x,0);
        }

        nextPanel();
        drawAxes("t",0,1, "y",0,panelDim);
        BezierCurve y_only = curve.justY(dim-2*pad);
        y_only.draw();

        stroke(255,0,255);
        float[] ty = y_only.getInflections();
        for(float t: ty) {
          if(t==0 || t==1) continue;
          Point p = y_only.getPoint(t);
          ellipse(p.x,p.y,5,5);
          line(p.x,p.y-3,p.x,0);
        }
      }</textarea>

      <textarea class="sketch-code" data-sketch-preset="threepanel" data-sketch-title="Cubic Bézier curve components">
      void setupCurve() {
        setupDefaultCubic();
      }

      void drawCurve(BezierCurve curve) {
        additionals();
        curve.draw();

        noAdditionals();
        usePanelPadding();

        nextPanel();
        drawAxes("t",0,1, "x",0,panelDim);
        BezierCurve x_only = curve.justX(dim-2*pad);
        x_only.draw();

        stroke(255,0,0);
        float[] tx = x_only.getInflections();
        for(float t: tx) {
          if(t==0 || t==1) continue;
          Point p = x_only.getPoint(t);
          ellipse(p.x,p.y,5,5);
          line(p.x,p.y-3,p.x,0);
        }

        nextPanel();
        drawAxes("t",0,1, "y",0,panelDim);
        BezierCurve y_only = curve.justY(dim-2*pad);
        y_only.draw();

        stroke(255,0,255);
        float[] ty = y_only.getInflections();
        for(float t: ty) {
          if(t==0 || t==1) continue;
          Point p = y_only.getPoint(t);
          ellipse(p.x,p.y,5,5);
          line(p.x,p.y-3,p.x,0);
        }
      }</textarea>
    </section>

    <section id="boundingbox">
      <h2>Bounding boxes</h2>

      <p>If we have the extremities, and the start/end points, a simple for loop that tests for min/max values for
      x and y means we have the four values we need to box in our curve:

      <p id="bounds_p"><i>Computing the bounding box for a Bézier curve</i></p>
      <ol>
        <li>Find all <i>t</i> value(s) for the curve's x- and y-roots.</li>
        <li>Discard any <i>t</i> value that's lower than 0 or higher than 1, because Bézier curves only use the interval [0,1].</li>
        <li>Determine the lowest and highest value when plugging the values <i>t=0</i>, <i>t=1</i> and each of the found
        roots into the original functions: the lowest value is the lower bound, and the highest value is the upper
        bound for the bounding box we want to construct.</li>
      </ol>

      <p>Applying this approach to our previous root finding, we get the following bounding boxes (with curve
      extremites colored the same as in the root finding graphics):</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Quadratic Bézier bounding box">
      void setupCurve() {
        setupDefaultQuadratic();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();

        stroke(255,0,0);
        BezierCurve x_only = curve.justX(dim-2*pad);
        float[] tx = x_only.getInflections();
        for(float t: tx) {
          if(t==0 || t==1) continue;
          Point p = curve.getPoint(t);
          ellipse(p.x,p.y,5,5);
        }

        stroke(255,0,255);
        BezierCurve y_only = curve.justY(dim-2*pad);
        float[] ty = y_only.getInflections();
        for(float t: ty) {
          if(t==0 || t==1) continue;
          Point p = curve.getPoint(t);
          ellipse(p.x,p.y,5,5);
        }

        drawBoundingBox(curve.generateBoundingBox());
      }</textarea>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Cubic Bézier bounding box">
      void setupCurve() {
        setupDefaultCubic();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();

        stroke(255,0,0);
        BezierCurve x_only = curve.justX(dim-2*pad);
        float[] tx = x_only.getInflections();
        for(float t: tx) {
          if(t==0 || t==1) continue;
          Point p = curve.getPoint(t);
          ellipse(p.x,p.y,5,5);
        }

        stroke(255,0,255);
        BezierCurve y_only = curve.justY(dim-2*pad);
        float[] ty = y_only.getInflections();
        for(float t: ty) {
          if(t==0 || t==1) continue;
          Point p = curve.getPoint(t);
          ellipse(p.x,p.y,5,5);
        }

        drawBoundingBox(curve.generateBoundingBox());
      }</textarea>

      <p>We can construct even nicer boxes by aligning them along our curve, rather than along the x- and y-axis,
      but in order to do so we first need to look at how aligning works.</p>
    </section>

    <section id="aligning">
      <h2>Aligning curves</h2>

      <p>While there are an incredible number of curves we can define by varying the x- and y-coordinates for
      the control points, not all curves are actually distinct. For instance, if we define a curve, and then
      rotate it 90 degrees, it's still the same curve, and we'll find its extremities in the same spots, just
      at different draw coordinates. As such, one way to make sure we're working with a "unique" curve is to
      "axis-align" it.</p>

      <p>Aligning also simplifies a curve's functions. We can translate (move) the curve so that the first
      point lies on (0,0), which turns our <i>n</i> term polynomial functions into <i>n-1</i> term functions.
      The order stays the same, but we have less terms. Then, we can rotate the curves so that the last point
      always lies on the x-axis, too, making its coordinate (...,0). This further simplifies the function for
      the y-component to an <i>n-2</i> term function. For instance, if we have a cubic curve such as this:</p>

      <p>\[
      \left \{ \begin{matrix}
        x = \underline{120} \cdot (1-t)^3 + \underline{35} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{220} \cdot 3 \cdot (1-t) \cdot t^2 + \underline{220} \cdot t^3 \\
        y = \underline{160} \cdot (1-t)^3 + \underline{200} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{260} \cdot 3 \cdot (1-t) \cdot t^2 + \underline{40} \cdot t^3
      \end{matrix} \right. \]</p>

      <p>Then translating it so that the first coordinate lies on (0,0), moving all <i>x</i> coordinates
      by -120, and all <i>y</i> coordinates by -160, gives us:</p>

      <p>\[
      \left \{ \begin{matrix}
        x = \underline{0} \cdot (1-t)^3 - \underline{85} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{100} \cdot 3 \cdot (1-t) \cdot t^2 + \underline{100} \cdot t^3 \\
        y = \underline{0} \cdot (1-t)^3 + \underline{40} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{100} \cdot 3 \cdot (1-t) \cdot t^2 - \underline{120} \cdot t^3
      \end{matrix} \right. \]</p>

      <p>If we then rotate the curve so that its end point lies on the x-axis, the coordinates (integer-rounded
      for illustrative purposes here) become:</p>

      <p>\[
      \left \{ \begin{matrix}
        x = \underline{0} \cdot (1-t)^3 + \underline{85} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{12} \cdot 3 \cdot (1-t) \cdot t^2 - \underline{156} \cdot t^3 \\
        y = \underline{0} \cdot (1-t)^3 + \underline{40} \cdot 3 \cdot (1-t)^2 \cdot t - \underline{140} \cdot 3 \cdot (1-t) \cdot t^2 + \underline{0} \cdot t^3
      \end{matrix} \right. \]</p>

      <p>If we drop all the zero-terms, this gives us:</p>

      <p>\[
      \left \{ \begin{array}{l}
        x = \underline{85} \cdot 3 \cdot (1-t)^2 \cdot t + \underline{13} \cdot 3 \cdot (1-t) \cdot t^2 - \underline{156} \cdot t^3 \\
        y = \underline{40} \cdot 3 \cdot (1-t)^2 \cdot t - \underline{141} \cdot 3 \cdot (1-t) \cdot t^2
      \end{array} \right. \]</p>

      <p>We our original curve definition has been simplified considerably. The following graphics
      illustrate the result of aligning our example curves to the x-axis, with the cubic case using
      the coordinates that were just used in the example formulae:</p>


      <textarea class="sketch-code" data-sketch-preset="twopanel" data-sketch-title="Aligning a quadratic curve">
      void setupCurve() {
        setupDefaultQuadratic();
      }

      void drawCurve(BezierCurve curve) {
        additionals();
        curve.draw();

        nextPanel();
        stroke(0);
        line(0,0,0,dim);

        stroke(0,50);
        translate(3*dim/4,dim/2);
        line(-3*dim/4,0,dim/4,0);
        line(0,-dim/2,0,dim/2);

        curve.align().draw(color(150));
      }</textarea>

      <textarea class="sketch-code" data-sketch-preset="twopanel" data-sketch-title="Aligning a cubic curve">
      void setupCurve() {
        setupDefaultCubic();
      }

      void drawCurve(BezierCurve curve) {
        additionals();
        curve.draw();

        nextPanel();
        stroke(0);
        line(0,0,0,dim);

        stroke(0,50);
        translate(3*dim/4,dim/2);
        line(-3*dim/4,0,dim/4,0);
        line(0,-dim/2,0,dim/2);

        curve.align().draw(color(150));
      }</textarea>
    </section>

    <section id="tightbounds">
      <h2>Tight boxes</h2>

      <p>With our knowledge of bounding boxes, and curve alignment, We can now form the "tight" bounding box for
      curves. We first align  our curve, recording the translation we performed, "T", and the rotation angle we
      used, "R". We then determine the aligned curve's normal bounding box. Once we have that, we can map that
      bounding box back to our original curve by rotating it by -R, and then translating it by -T. We now have
      nice tight bounding boxes for our curves:</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Tight quadratic Bézier bounding box">
      void setupCurve() {
        setupDefaultQuadratic();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();
        drawBoundingBox(curve.generateTightBoundingBox());
      }</textarea>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Tight cubic Bézier bounding box">
      void setupCurve() {
        setupDefaultCubic();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();
        drawBoundingBox(curve.generateTightBoundingBox());
      }</textarea>

      <p>These are, strictly speaking, not necessarily the tightest possible bounding boxes. It is possible to compute
      the optimal bounding box by determining which spanning lines we need to effect a minimal box area, but because
      of the parametric nature of Bézier curves this is actually a rather costly operation, and the gain in bounding
      precision is often not worth it. If there is high demand for it, I'll add a section on how to precisely compute
      the best fit bounding box, but the math is fairly grueling and just not really worth spending time on.</p>
    </section>

    <section id="pointvectors">
      <h2>Tangents and normals</h2>

      <p>If you want to move objects along a curve, or "away from" a curve, the two vectors you're most interested
      in are the tangent vector and normal vector for curve points. These are actually really easy to find. For
      moving, and orienting, along a curve we use the tangent, which indicates the direction travel at specific
      points, and is literally just the first derivative of our curve:</p>

      <p>\[
      \left \{ \begin{matrix}
        tangent_x(t) = d_x(t) = B'_x(t) \\
        tangent_y(t) = d_y(t) = B'_y(t)
      \end{matrix} \right. \]</p>

      <p>This gives us the directional vector we want. We can normalize it to give us uniform directional vectors
      (having a length of 1.0) at each point, and then do whatever it is we want to do based on those directions:</p>

      <p>\[
      \left \{ \begin{matrix}
        \hat{x}(t) = || d_x(t) ||
                   =\frac{tangent_x(t)}{ || tangent(t) || }
                   = \frac{B'_x(t)}{\sqrt{B'_x(t)^2 + B'_y(t)^2}} \\
        \hat{y}(t) = || d_y(t) ||
                   = \frac{tangent_y(t)}{ || tangent(t) || }
                   = \frac{B'_y(t)}{\sqrt{B'_x(t)^2 + B'_y(t)^2}}
      \end{matrix} \right. \]</p>

      <p>If we want to move away from the curve instead, perpendicular to the curve at some point <i>t</i>, we want
      the "normal" vector. This vector runs at a right angle to the direction of the curve, and is typically of lenght
      1.0, so all we have to do is rotate the normalized directional vector and we're done:</p>

      <p>\[
      \left \{ \begin{matrix}
        normal_x(t) = \hat{x}(t) \cdot \cos{\frac{\pi}{2}} - \hat{y}(t) \cdot \sin{\frac{\pi}{2}}\\
        normal_y(t) = \hat{x}(t) \cdot \sin{\frac{\pi}{2}} + \hat{y}(t) \cdot \cos{\frac{\pi}{2}}
      \end{matrix} \right. \]</p>

      <p>The following two graphics show the tangent and normal along a quadratic and cubic curve, with
      the direction vector coloured blue, and the normal vector coloured red.</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Quadratic Bézier tangents and normals">
      void setupCurve() {
        setupDefaultQuadratic();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw(color(0,40));
        float t, d = 15;
        Point p, tg, n;
        for(int i=0; i<=10; i++) {
          t = i/10.0;
          p = curve.getPoint(t);
          tg = curve.getDerivativePoint(t).normalize();
          n = curve.getNormal(t);
          stroke(0,0,255);
          line(p.x, p.y, p.x+d*tg.x, p.y+d*tg.y);
          stroke(200,0,0);
          line(p.x, p.y, p.x+d*n.x, p.y+d*n.y);
          stroke(0);
          ellipse(p.x, p.y, 5, 5);
        }
      }</textarea>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Cubic Bézier tangents and normals">
      void setupCurve() {
        setupDefaultCubic();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw(color(0,40));
        float t, d = 15;
        Point p, tg, n;
        for(int i=0; i<=10; i++) {
          t = i/10.0;
          p = curve.getPoint(t);
          tg = curve.getDerivativePoint(t).normalize();
          n = curve.getNormal(t);
          stroke(0,0,255);
          line(p.x, p.y, p.x+d*tg.x, p.y+d*tg.y);
          stroke(200,0,0);
          line(p.x, p.y, p.x+d*n.x, p.y+d*n.y);
          stroke(0);
          ellipse(p.x, p.y, 5, 5);
        }
      }</textarea>
    </section>

    <section id="intersections">
      <h2>Intersections</h2>

      <p>Let's look at some more things we will want to do with Bézier curves. Almost immediately after figuring out how to
      get bounding boxes to work, people tend to run into the problem that even though the minimal bounding box (based on
      rotation) is tight, it's not sufficient to perform collision dectection ("<i>does curve C touch, or pass through, curve
      or line L?</i>"). In order to do this, we need to know whether or not there's an intersection on the actual curve.</p>

      <p>We'll do this in steps, because it's a bit of a journey to get to curve/curve intersection checking. First, let's
      start simple, by implementing a line-line intersection checker. While we can solve this the traditional calculus way
      (determine the functions for both lines, then compute the intersection by equating them and solving for two unknowns),
      linear algebra actually offers a nicer solution:</p>

      <p id="intersection_ll">if we have two line segments with two coordinates each, segments A-B and C-D, we can find the
      intersection of the lines these segments are an intervals on by linear algebra, using the procedure outlined in this
      <a href="http://www.topcoder.com/tc?module=Static&d1=tutorials&d2=geometry2#line_line_intersection">top coder</a> article.
      Of course, we need to make sure that the intersection isn't just on the lines our line segments lie on, but also on our
      line segments themselves, so after we find the intersection we need to verify it lies without the bounds of our original
      line segments.</p>

      <p>The following graphic implements this intersection detection, showing a red point for an intersection on the lines
      our segments lie on (thus being a virtual intersection point), and a green point for an intersection that lies on
      both segments (being a real intersection point).</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Line/line intersections">
      Point p1, p2, p3, p4;

      void setupCurve() {
        p1 = new Point(50,50);
        p2 = new Point(150,110);
        curves.add(new BezierCurve(new Point[]{p1,p2}));
        p3 = new Point(50,250);
        p4 = new Point(170,170);
        curves.add(new BezierCurve(new Point[]{p3,p4}));
      }

      void drawCurve(BezierCurve curve) {
        // draw the lines through p1/p2 and p3/p4
        stroke(0,50);
        float dx = 10*(p2.x-p1.x), dy = 10*(p2.y-p1.y);
        line(p1.x-dx,p1.y-dy,p2.x+dx,p2.y+dy);
        dx = 10*(p4.x-p3.x); dy = 10*(p4.y-p3.y);
        line(p3.x-dx,p3.y-dy,p4.x+dx,p4.y+dy);

        // show the line segments
        curves.get(0).draw();
        curves.get(1).draw();

        // show the intersection point
        Point ntr = comp.getProjection(p1,p2,p3,p4);

        // red if virtual intersection, green if real
        boolean oncurves = true;
        if(min(p1.x,p2.x) > ntr.x || ntr.x > max(p1.x,p2.x) ||
           min(p1.y,p2.y) > ntr.y || ntr.y > max(p1.y,p2.y)) oncurves = false;
        if(oncurves) {
          if(min(p3.x,p4.x) > ntr.x || ntr.x > max(p3.x,p4.x) ||
            min(p3.y,p4.y) > ntr.y || ntr.y > max(p3.y,p4.y)) oncurves = false; }

        stroke(oncurves?0:255, oncurves?255:0, 0);
        ellipse(ntr.x,ntr.y,5,5);
      }</textarea>

      <p>Curve/line intersection is more work, but we've already seen the techniques we need to use in order
      to perform it: first we translate/rotate both the line and curve together, in such a way that the line
      coincides with the x-axis. This will position the curve in a way that makes it cross the line at
      points where its y-function is zero. By doing this, the problem of finding intersections between a
      curve and a line has now become the problem of performing root finding on our translated/rotated curve.
      One Newton-Raphson root finding round later and the intersections have been found:</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Quadratic curve/line intersections">
      Point p1, p2;

      void setupCurve() {
        p1 = new Point(40,60);
        p2 = new Point(260,200);
        curves.add(new BezierCurve(new Point[]{
          p1, p2
        }));
        curves.add(new BezierCurve(new Point[]{
          new Point(25,150),
          new Point(180,30),
          new Point(230,250)
        }));
      }

      void drawCurve(BezierCurve curve) {
        curves.get(0).draw();
        curves.get(1).draw();

        BezierCurve aligned = curves.get(1).align(p1,p2);
        float[] roots = comp.findAllRoots(0, aligned.y_values);
        fill(150,0,150);
        float x, y;
        for(float t: roots) {
          if(t<0 || t>1) continue;
          x = curves.get(1).getXValue(t);
          y = curves.get(1).getYValue(t);
          ellipse(x,y,5,5);
          text(""+round(1000*t)/1000,x+10,y);
        }
      }</textarea>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Cubic curve/line intersections">
      Point p1, p2;

      void setupCurve() {
        p1 = new Point(100,20);
        p2 = new Point(195,255);
        curves.add(new BezierCurve(new Point[]{
          p1, p2
        }));
        curves.add(new BezierCurve(new Point[]{
          new Point(150,125),
          new Point(40,30),
          new Point(270,115),
          new Point(145,200)
        }));
      }

      void drawCurve(BezierCurve curve) {
        curves.get(0).draw();
        curves.get(1).draw();

        BezierCurve aligned = curves.get(1).align(p1,p2);
        float[] roots = comp.findAllRoots(0, aligned.y_values);
        fill(150,0,150);
        float x, y;
        for(float t: roots) {
          if(t<0 || t>1) continue;
          x = curves.get(1).getXValue(t);
          y = curves.get(1).getYValue(t);
          ellipse(x,y,5,5);
          text(""+round(1000*t)/1000,x+10,y);
        }
      }</textarea>

      <p>Curve/curve intersection, however, is more complicated. Since we have no straight line to align to, we
      can't simply align one of the curves and be left with a simple procedure. Instead, we'll need to apply two
      techniques we've not covered yet: de Casteljau's algorithm, and curve splitting.</p>
    </section>

    <section id="decasteljau">
      <h2>de Casteljau's algorithm</h2>

      <p>This algorithm is the basis for drawing arbitrarily complex Bézier curves. It's really straight forward:</p>

      <ul>
        <li>treat <i>t</i> as a ratio (which it is). t=0 is 0% along a line, t=1 is 100% along a line.</li>
        <li>Take all lines between the curve's defining points. For an order <i>n</i> curve, that's <i>n</i> lines.</li>
        <li>Place markers along each of these line, at distance <i>t</i>. So if <i>t</i> is 0.2, place the mark
            at 20% from the start, 80% from the end.</li>
        <li>Now form lines between <i>those</i> points. This gives <i>n-1</i> lines.</li>
        <li>Place markers along each of these line at distance <i>t</i>.</li>
        <li>Form lines between <i>those</i> points. This'll be <i>n-2</i> lines.</li>
        <li>place markers, form lines, place markers, etc.</li>
        <li>repeat this until you have only one line left. The point <i>t</i> on that line coincides with the
            original curve point at <i>t</i>.</li>
      </ul>

      <p>To see this in action, click the following sketch. This sketch has a curve that can be lowered and elevated,
      and will show de Casteljau's "skeleton" around the curve, showing how it's determining where to draw the curve's
      point for every <i>t</i> value. To pause or resume, simply click or hit space bar (when focussed on the sketch).</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Traversing a curve using de Casteljau's algorithm">
      void setupCurve() {
        //setupDefaultCubic();
        Point[] points = {
          new Point(65,25),
          new Point(5,150),
          new Point(80,290),
          new Point(220,235),
          new Point(250,150),
          new Point(135,125),
        };
        curves.add(new BezierCurve(points));
        reorder();
        animate();
        pause();
        span();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();
        Point p = curve.getPoint(t);
        ellipse(p.x, p.y, 5, 5);
        drawSpan(curve, t);
      }</textarea>
    </section>

    <section id="splitting">
      <h2>Splitting curves</h2>

      <p>With de Casteljau's algorithm we also find all the points we need to split up a Bézier curve into two, smaller
      curves, which taken together form the original curve. When we construct de Casteljau's skeleton for some value
      <i>t</i>, the procedure gives us all the points we need to split a curve at that <i>t</i> value: one curve is defined
      by all the inside skeleton points found prior to our on-curve point, with the other curve being defined by all the
      inside skeleton points after our on-curve point.</p>

      <p>This is best illustrated with an animated graphic:</p>

      <textarea class="sketch-code" data-sketch-preset="threepanel" data-sketch-title="Bézier curve splitting. Curve order can be lowered/elevated.">
      void setupCurve() {
        setupDefaultCubic();
        reorder();
        animate();
        pause();
        span();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();
        Point p = curve.getPoint(t);
        ellipse(p.x, p.y, 5, 5);
        drawSpan(curve, t);

        BezierCurve[] segments = curve.split(t);
        usePanelPadding();

        nextPanel();
        drawAxes("first curve x",0,panelDim, "first\ncurve\ny",0,panelDim);
        drawSpan(curve, t);
        segments[0].draw();

        nextPanel();
        drawAxes("second curve x",0,panelDim, "second\ncurve\ny",0,panelDim);
        drawSpan(curve, t);
        segments[1].draw();
      }</textarea>
    </section>

    <section id="curveintersection">
      <h2>Curve/curve intersection</h2>

      <p>Using de Casteljau's algorithm to split the curve we can now implement curve/curve intersection
      finding using a "divide and conquer" technique: take two curves <i>C<sub>1</sub></i> and <i>C<sub>2</sub></i>,
      and treat them as a pair. If their bounding boxes overlap, split up each curve into two subcurves,
      <i>C<sub>1.1</sub></i>, <i>C<sub>1.2</sub></i>, <i>C<sub>2.1</sub></i> and <i>C<sub>2.2</sub></i>,
      and form four new pairs (<i>C<sub>1.1</sub></i>,<i>C<sub>2.1</sub></i>), (<i>C<sub>1.1</sub></i>,
      <i>C<sub>2.2</sub></i>), (<i>C<sub>1.2</sub></i>,<i>C<sub>2.1</sub></i>), and (<i>C<sub>1.2</sub></i>,
      <i>C<sub>2.2</sub></i>). If their bounding boxes do not overlap, discard the pair, as there is no
      intersection between this pair of curves. If there was overlap, for each of the newly formed pairs,
      perform the same evaluation. Once the subcurves we form are so small that they effectively occupy
      sub-pixel areas, we consider an intersection found.</p>

      <p>This algorithm will start with a single pair, "balloon" until it runs in parallel for a large
      number of potential subpairs, and then taper back down as it homes in on intersection coordinates,
      ending up with as many pairs as there are intersections.</p>

      <p>The following graphic applies this algorithm to a pair of cubic curves, slowed down so that
      you can see the algorithm in action. Click the button to run the algorithm, after setting up
      your curves in some creative arrangment: <button id="clippingButton">detect</button></p>

      <textarea class="sketch-code" data-sketch-preset="clipping" data-sketch-title="Curve/curve intersections">
      void iterate() {
        if(pairs.size()==0) {
          iterated = false;
          drawResult();
          noAnimate();
          return; }

        fill(0);
        text("iteration "+(iterationCount++), 10,20);

        newPairs.clear();
        for(CurvePair cp: pairs) {
          cp.draw(getColor(random(999)));
          if(cp.hasOverlap()) {
            if(cp.smallEnough()) { finals.add(cp); }
            else {
              CurvePair[] expanded = cp.splitAndCombine();
              for(CurvePair ncp: expanded) {
                newPairs.add(ncp);
              }
            }
          }
        }
        pairs.clear();
        for(CurvePair cp: newPairs) { pairs.add(cp); }
      }
      </textarea>
    </section>

    <section id="moulding">
      <h2>Curve moulding (using the projection ratio)</h2>

      <p>De Casteljau's algorithm is the pivotal algorithm when it comes to Bézier curves. You can use it not just to split
      curves, but also to draw them efficiently (especially for high-order Bézier curves), as well as to come up with curves
      based on three points and a tangent. Particularly this last thing is really useful because it lets us "mould" a curve,
      by picking it up at some point, and dragging that point around to change the curve's shape.</p>

      <p>How does that work? Succinctly: we run de Casteljau's algorithm in reverse!</p>

      <p>Let's start out with a pre-existing curve, defined by <i>start</i>, two control points, and <i>end</i>. We can
      mould this curve by picking a point somewhere on the curve, at some <i>t</i> value, and the moving it to a new
      location and reconstructing the curve that goes through <i>start</i>, our new point with the original tangent,
      and </i>end</i>. In order to see how and why we can do this, let's look at some identity information for Bézier
      curves. There's actually a hidden goldmine of identities that we can exploit when doing Bézier operations, and
      this will only scratch the surface. But, in a good way!</p>

      <p>In the following graphic, click anywhere on the curves to see the identity information that we'll
      be using to run de Casteljau in reverse:</p>

      <textarea class="sketch-code" data-sketch-preset="abc" data-sketch-title="Projections in a quadratic Bézier curve">
      void setupCurve() {
        setupDefaultQuadratic();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();

        if(Bt != -1) {
          Point[] abc = curve.getABC(Bt);
          drawABC(curve, abc);
        }
      }</textarea>

      <textarea class="sketch-code" data-sketch-preset="abc" data-sketch-title="Projections in a cubic Bézier curve">
      void setupCurve() {
        setupDefaultCubic();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();

        if(Bt != -1) {
          Point[] abc = curve.getABC(Bt);
          drawABC(curve, abc);
        }
      }</textarea>

      <p>So, what exactly do we see in these graphics? First off, there's the three points <i>A</i>, <i>B</i> and
      <i>C</i>.</p>

      <p>Point <i>B</i> is our "on curve" point, A is the first "strut" point when running de Casteljau's
      algorithm in reverse; for quadratic curves, this happens to also be the curve's control point. For cubic
      curves, it's the "top of the triangle" for the struts that lead to point <i>B</i>. Point
      <i>C</i>, finally, is the intersection of the line that goes through <i>A</i> and <i>B</i> and the baseline,
      between our start and end points.</p>

      <p>There is some important identity information here: as long as we don't pick a new <i>t</i> coordinate,
      the location of point <i>C</i> on the line <i>start-end</i> represents a fixed ratio distance. We can drag
      around the control points as much as we like, that point won't move at all, and if we can drag around
      the start or end point, C will stay at the same ratio-value. For instance, if it was located midway between
      start and end, it'll stay midway between start and end, even if the line segment between start and end
      becomes longer or shorter.</p>

      <p>We can also see that the distances for the lines <i>d1 = A-B</i> and <i>d2 = B-C</i> may vary, but the
      ratio between them, <i>d1/d2</i>, is a constant value. We can drag any of the start, end, or control points
      around as much as we like, but that value also stays the same.</p>

      <div class="note">
        <p>In fact, because the distance ratio is a fixed value for each point <i>B</i>, which we get by picking
        some <i>t</i> value on our curve, the distance ratio is actually an identity function for Bézier curves.
        If we were to plot all the ratio values for all possible <i>t</i> values for quadratic and cubic curves,
        we'd see two very interesting functions: asymptotic at <i>t=0</i> and <i>t=1</i>, tending towards positive
        infinity, with a zero-derivative minimum at <i>t=0.5</i>.</p>

        <p>Since these are ratios, we can actually express the ratio values as a function of <i>t</i>. I actually
        failed at coming up with the precise functions, but thanks to some help from
        <a href="http://mathoverflow.net/questions/122257/finding-the-formula-for-Bézier-curve-ratios-hull-point-point-baseline">Boris
        Zbarsky</a> we can see that the ratio functions are actually remarkably simple:</p>

        <table style="width:100%; border:0"><tr><td>
          <p>Quadratic curves:\[
            ratio(t)_2 = \left | \frac{2t^2 - 2t}{2t^2 - 2t + 1} \right |
          \]</p>
        </td><td>
          <p>Cubic curves: \[
            ratio(t)_3 = \left | \frac{t^3 + (1-t)^3}{t^3 + (1-t)^3 - 1} \right |
          \]</p>
        </td></tr></table>

        <p>Unfortunately, this trick only works for quadratic and cubic curves. Once we hit higher order curves,
        things become a lot less predictable; the "fixed point <i>C</i>" is no longer fixed, moving around as we
        move the control points, and projections of <i>B</i> onto the line between start and end may actually
        lie on that line before the start, or after the end, and there are no simple ratios that we can exploit.</p>
      </div>

      <p>So, with this knowledge, let's change a curve's shape by click-dragging some part of it. The follow
      graphics let us click-drag somewhere on the curve, repositioning point <i>B</i> according to a simple
      rule: we keep the original point <i>B</i>'s tangent, because while we're free to assign our new point
      any tangent we like, coming up with an aesthetically pleasing new tangent is probably material for an
      entire paper on curve design.</p>

      <p>Quadratic and cubic Bézier curves have a nice property that allows curve moulding (picking
      a point on the curve and changing the curve shape by moving it around), based on the fact that
      there is always a line {A,C} through the on-curve point B, where C lies on the baseline (the
      line between the curve's start and end coordinates) and the ratio between distance d1 = A-B
      and d2 = B-C is fixed. The following to sketches illustrate this line and the three points
      involved: click-drag on the curves to see this visualised.</p>

      <textarea class="sketch-code" data-sketch-preset="moulding" data-sketch-title="Moulding a quadratic Bézier curve">
      void setupCurve() {
        setupDefaultQuadratic();
        mould();
        span();
        additionals();
      }

      void mouldCurve(BezierCurve curve, int mx, int my) {
        if(Bt != -1) {
          B = new Point(mx, my);
          BezierCurve newcurve = comp.generateCurve(curve.order, curve.points[0], B, curve.points[curve.order], Bt);
          curves.clear();
          curves.add(newcurve);
        }
      }</textarea>

      <textarea class="sketch-code" data-sketch-preset="moulding" data-sketch-title="Moulding a cubic Bézier curve">
      void setupCurve() {
        setupDefaultCubic();
        mould();
        span();
        additionals();
      }

      void mouldCurve(BezierCurve curve, int mx, int my) {
        if(Bt != -1) {
          B = new Point(mx, my);
          BezierCurve newcurve = comp.generateCurve(curve.order, curve.points[0], B, curve.points[curve.order], Bt, tangents);
          curves.clear();
          curves.add(newcurve);
        }
      }</textarea>
    </section>

    <section id="arclength">
      <h2>Arc length</h2>

      <p>How long is a Bézier curve? As it turns out, that's not actually an easy question, because the answer
      requires math that —much like root finding— cannot generally be solved the traditional way. If we
      have a parametric curve with <i>f<sub>x</sub>(t)</i> and <i>f<sub>y</sub>(t)</i>, then the length of the
      curve, measured from start point to some point <i>t = z</i>, is computed using the following seemingly
      straight forward (if a bit overwhelming) formula:</p>

      <p>\[
        \int_{0}^{z}\sqrt{f_x'(t)^2+f_y'(t)^2} dt
      \]</p>

      <p>or, more commonly written using leibnitz notation as:</p>

      <p>\[
        length = \int_{0}^{z}\sqrt{ \left (dx/dt \right )^2+\left (dy/dt \right )^2} dt
      \]</p>

      <p>This formula says that the length of a parametric curve is in fact equal to the <b>area</b> underneath a function that
      looks a remarkable amount like pythagoras' rule for computing the diagonal of a straight angled triangle. This sounds
      pretty simple, right? Sadly, it's far from simple... cutting straight to after the chase is over: for quadratic curves,
      this formula generates an <a href="http://www.wolframalpha.com/input/?i=antiderivative+for+sqrt((2*(1-t)*t*B+%2b+t^2*C)'^2+%2b+(2*(1-t)*t*E)'^2)&incParTime=true">unwieldy computation</a>,
      and we're simply not going to implement things that way. For cubic Bézier curves, things get even more fun, because there
      is no "closed form" solution, meaning that due to the way calculus works, there is no generic formula that allows you to
      calculate the arc length. Let me just repeat this, because it's fairly crucial: <strong><em>for cubic and higher Bézier curves,
      there are values for the parameters such that this function cannot be solved</em></strong>.</p>

      <p>So we turn to numerical approaches again. The method we'll look at here is the
      <a href="http://www.youtube.com/watch?v=unWguclP-Ds&feature=BFa&list=PLC8FC40C714F5E60F&index=1">Gauss
      quadrature</a>. This approximation is a really neat trick, because for any <i>n<sup>th</sup></i> degree polynomial
      it finds approximated values for an integral really efficiently. Explaining this procedure in length is way beyond
      the scope of this page, so if you're interested in finding out why it works, I can recommend the University of
      South Florida video lecture on the procedure, linked in this very paragraph. The general solution we're looking
      for is the following:</p>

      <p>\[
        \int_{-1}^{1}\sqrt{ \left (dx/dt \right )^2+\left (dy/dt \right )^2} dt
        ≃
        \left [ C_1 \cdot f\left(t_1\right)
               \ +\ ...
               \ +\ C_n \cdot f\left(t_n\right)
        \right ]
        =
        \sum_{i=1}^{n}{C_i \cdot f\left(t_i\right)}
      \]</p>

      <p>In plain text: "we can express the length either as an integral function, which we know we cannot always solve,
      or as an infinite sum of rectangular strips, approximated by using some finite but high number of strips
      (with widths <i>C<sub>1</sub></i> for the first strip, <i>C<sub>2</sub></i> for the second, etc., and
      with heights <i>f(t<sub>1</sub>)</i> for the first, <i>f(t<sub>2</sub>)</i> for the second, etc.)
      and then simply add up the areas for all strips.</p>

      <p>Since computing the area for a rectangle is just width times height, this second approach is computationally
      cheap, provided we can also cheaply come up with sensible values for those <i>C<sub>1</sub></i>, <i>C<sub>2</sub></i>,
      etc. A naive way is to simply create <i>n</i> strips all with the same width, but there is a far better way,
      using special values for <i>C</i> and <i>f(t)</i> depending on the value of <i>n</i>, which indicates how many
      strips we'll use.</p>

      <div class="note">

        <p>Note that one requirement for the approach we'll use is that the integral must run from -1 to 1. That's no good, because
        we're dealing with Bézier curves, and the length of a section of curve applies to values which run from 0 to "some
        value smaller than or equal to 1" (let's call that value <i>z</i>). Thankfully, we can quite easily transform any
        integral interval to any other integral interval, by shifting and scaling the inputs. Doing so, we get the
        following:</p>

        <p>\[
          \int_{0}^{z}\sqrt{ \left (dx/dt \right )^2+\left (dy/dt \right )^2} dt
          ≃
          \frac{z}{2} \cdot \left [ C_1 \cdot f\left(\frac{z}{2} \cdot t_1 + \frac{z}{2}\right)
                                    + ...
                                    + C_n \cdot f\left(\frac{z}{2} \cdot t_n + \frac{z}{2}\right)
                            \right ]
          =
          \frac{z}{2} \cdot \sum_{i=1}^{n}{C_i \cdot f\left(\frac{z}{2} \cdot t_i + \frac{z}{2}\right)}
        \]</p>

        <p>That may look a bit more complicated, but the fraction involving <i>z</i> is a fixed number,
        so the summation, and the evaluation of the <i>f(t)</i> values are still pretty simple.</p>

        <p>So, what do we need to perform this calculation? For one, we'll need an explicit formula for <i>f(t)</i>,
        because that derivative notation is handy on paper, but not when we have to implement it. We'll also
        need to know what these <i>C<sub>i</sub></i> and <i>t<sub>i</sub></i> values should be. Luckily, that's
        less work because there are actually many tables available that give these values, for any <i>n</i>,
        so if we want to approximate our integral with only two terms (which is a bit low, really) then
        <a href="legendre-gauss.html">these tables</a> would tell us that for <i>n=2</i> we must use the following values:</p>

        <p>\[\begin{array}{l}
        C_1 = 1 \\
        C_2 = 1 \\
        t_1 = - \frac{1}{\sqrt{3}} \\
        t_2 = + \frac{1}{\sqrt{3}}
        \end{array}\]</p>

        <p>Which means that in order for us to approximate the integral, we must plug these values into the approximate
        function, which gives us:</p>

        <p>\[

        \int_{0}^{z}\sqrt{ \left (dx/dt \right )^2+\left (dy/dt \right )^2} dt
        ≃
        \frac{z}{2} \cdot \left [ f\left( \frac{z}{2} \cdot \frac{-1}{\sqrt{3}} + \frac{z}{2} \right)
                      + f\left( \frac{z}{2} \cdot \frac{1}{\sqrt{3}} + \frac{z}{2} \right)
                  \right ]
        \]</p>

        <p>We can program that pretty easily, provided we have that <i>f(t)</i> available, which we do,
        as we know the full description for the Bézier curve functions B<sub>x</sub>(t) and B<sub>y</sub>(t).</p>
      </div>

      <p>So, with this information we can determine the approximate length of a Bézier curve by computing the
      Legendre-Gauss sum. The following graphic show a cubic curve, with its computed lengths, but the sketch
      allows curve order elevation and lowering.</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Arc length for a Bézier curve">
      void setupCurve() {
        setupDefaultCubic();
        reorder();
      }

      void drawCurve(BezierCurve curve) {
        curve.draw();
        pushStyle();
        fill(0);
        float f = curve.getCurveLength();
        if (f<0) {
          curves.clear();
          curves.add(curve.lower());
          redraw();
          return;
        }
        f = int(1000*f)/1000;
        text("curve length: "+f+"px", 15, 15);
        popStyle();
      }</textarea>
    </section>

    <section id="projections">
      <h2>Projecting a point onto a Bézier curve</h2>

      <p>Say we have a Bézier curve and some point, not on the curve, of which we want to know which
      <i>t</i> value on the curve gives us an on-curve point closest to our off-curve point. Or: say
      we want to find the projection of a random point onto a curve. How do we do that?</p>

      <p>If the Bézier curve is of low enough order, we might be able to <a href="http://jazzros.blogspot.ca/2011/03/projecting-point-on-bezier-curve.html">work out the math for how
      to do this</a>, and get a perfect <i>t</i> value back, but in general this is an incredibly hard
      problem and the easiest solution is, really, a numerical approach again. It's a bit like the
      Newton-Raphson approach in that we'll try some <i>t</i> values, checking which is closest to
      our point, and then refine our search around the closest <i>t</i> value. We keep doing this
      until we've reach the desired fidelity: given precision <i>p</i>, we stop if we find a value
      <i>t</i> such that the distance from <i>B(t)</i> to the off-curve point is smaller than the
      distance from <i>B(t-p)</i> or the distance from <i>B(t+p)</i>.</p>

      <p>The following graphic demonstrates this procedure. Simply move the cursor around, and
      if it does not lie on top of the curve, you will see a line that projects the cursor onto
      the curve based on an iteratively found "ideal" <i>t</i> value with precision 0.001.</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Projecting a point onto a Bézier curve">
      void setupCurve() {
        int d = dim - 2*pad;
        int order = 10;
        int[] c = {248,188,218,294,45,290,12,236,14,82,186,177,221,90,18,156,34,57,198,18};
        Point[] points = new Point[c.length/2];
        for(int i=0, e=c.length; i<e; i+=2) {
          points[i/2] = new Point(c[i], c[i+1]);
        }
        curves.add(new BezierCurve(points));
        redrawOnMove();
      }

      void drawCurve(BezierCurve curve) {
        additionals();
        curve.draw();

        if(curve.over(mouseX,mouseY) == -1) {
          float t = curve.getPointProjection(new Point(mouseX, mouseY));
          Point p = curve.getPoint(t);
          stroke(255,0,0);
          line(mouseX, mouseY, p.x, p.y);
        }
      }</textarea>

    </section>


    <section id="offsetting">
      <h2>Curve offsetting</h2>

      <p>Perhaps you are like me, and you've been writing various small programs that use Bézier curves in some way or another,
      and at some point you make the step to implementing path extrusion. But you don't want to do it pixel based, you want to
      stay in the vector world. You find that extruding lines is relatively easy, and tracing outlines is coming along nicely
      (although junction caps and fillets are a bit of a hassle), and then decide to do things properly and add Bézier curves
      to the mix. Now you have a problem.</p>

      <p>Unlike lines, you can't simply extrude a Bézier curve by taking a copy and moving it around, because of the curvatures;
      rather than a uniform thickness you get an extrusion that looks too thin in places, if you're lucky, but more likely will
      self-intersect. The trick, then, is to scale the curve, rather than simply copying it. But how do you scale a Bézier curve?</p>

      <p>Bottom line: <strong>you can't</strong>. So you cheat. We're not going to do true curve scaling, or rather curve
      offsetting, because that's impossible. Instead we're going to try to generate 'looks good enough' offset curves.</p>

      <div class="note">
        <h2>"What do you mean, you can't. Prove it."</h2>

        <p>First off, when I say "you can't" what I really mean is "you can't offset a Bézier curve with another
        Bézier curve". not even by using a really high order curve. You can find the function that describes the
        offset curve, but it won't be a polynomial, and as such it cannot be represented as a Bézier curve, which
        <strong>has</strong> to be a polynomial. Let's look at why this is:</p>

        <p>From a mathematical point of view, an offset curve <i>O(t)</i> is a curve such that, given our original curve
        <i>B(t)</i>, any point on <i>O(t)</i> is a fixed distance <i>d</i> away from coordinate <i>B(t)</i>.
        So let's math that:</p>

        <p>\[
          O(t) = B(t) + d
        \]</p>

        <p>However, we're working in 2D, and <i>d</i> is a single value, so we want to turn it into a vector. If we
        want a point distance <i>d</i> "away" from the curve <i>B(t)</i> then what we really mean is that we want
        a point at <i>d</i> times the "normal vector" from point <i>B(t)</i>, where the "normal" is a vector
        that runs perpendicular ("at a right angle") to the tangent at <i>B(t)</i>. Easy enough:</p>

        <p>\[
          O(t) = B(t) + d \cdot N(t)
        \]</p>

        <p>Now this still isnt very useful unless we know what the formula for <i>N(t)</i> is, so let's find out.
        <i>N(t)</i> runs perpendicular to the original curve tangent, and we know that the tangent is simply
        <i>B'(t)</i>, so we could just rotate that 90 degrees and be done with it. However, we need to ensure
        that <i>N(t)</i> has the same magnitude for every <i>t</i>, or the offset curve won't be at a uniform
        distance, thus not being an offset curve at all. The easiest way to guarantee this is to make sure
        <i>N(t)</i> always has length 1, which we can achieve by dividing <i>B'(t)</i> by its magnitude:</p>

        <p>\[
          N(t) \perp \left ( \frac{B'(t)}{\left || B'(t) \right || } \right )
        \]</p>

        <p>Determining the length requires computing an arc length, and this is where things get Tricky with
        a capital T. First off, to compute arc length from some start <i>a</i> to end <i>b</i>, we must use
        the formula we saw earlier. Noting that "length" is usually denoted with double vertical bars:</p>

        <p>\[
          \left || f(x,y) \right || = \int^b_a \sqrt{ f_x'^2 + f_y'^2}
        \]</p>

        <p>So if we want the length of the tangent, we plug in <i>B'(t)</i>, with <i>t = 0</i> as start and
        <i>t = 1</i> as end:</p>

        <p>\[
          \left || B'(t) \right || = \int^1_0 \sqrt{ B_x''(t)^2 + B_y''(t)^2}
        \]</p>

        <p>And that's where things go wrong. It doesn't even really matter what the second derivative for <i>B(t)</i>
        is, that square root is screwing everything up, because it turns our nice polynomials into things that are no
        longer polynomials.</p>

        <p>There is a small class of polynomials where the square root is also a polynomial, but
        they're utterly useless to us: any polynomial with unweighted binomial coefficients has a square root that is
        also a polynomial. Now, you might think that Bézier curves are just fine because they do, but they don't;
        remember that only the <strong>base</strong> function has binomial coefficients. That's before we factor
        in our coordinates, which turn it into a non-binomial polygon. The only way to make sure the functions
        stay binomial is to make all our coordinates have the same value. And that's not a curve, that's a point.
        We can already create offset curves for points, we call them circles, and they have much simpler functions
        than Bézier curves.</p>

        <p>So, since the tangent length isn't a polynomial, the normalised tangent won't be a polynomial either, which
        means <i>N(t)</i> won't be a polynomial, which means that <i>d</i> times <i>N(t)</i> won't be a polynomial,
        which means that, ultimately, <i>O(t)</i> won't be a polynomial, which means that even if we can determine the
        function for <i>O(t)</i> just fine (and that's far from trivial!), it simply cannot be represented as a
        Bézier curve.</p>

        <p>And that's one reason why Bézier curves are tricky: there are actually a <i>lot</i> of curvatures that
        cannot be represent with a Bézier curve at all. They can't even model their own offset curves. They're weird
        that way. So how do all those other programs do it? Well, much like we're about to do, they cheat. We're
        going to approximate an offset curve in a way that will look relatively close to what the real offset
        curve would look like, if we could compute it.</p>
      </div>

      <p>So, you cannot offset a Bézier curve perfectly with another Bézier curve, no matter how hight-order you make
      that other Bézier curve. However, we can chop up a curve into "safe" subcurves (where safe means that all the
      control points are always on a single side of the baseline, and the midpoint of the curve at <i>t=0.5</i> is
      roughly in the center of the polygon defined by the curve coordinates) and then point-scale those subcurves
      with respect to the curve's scaling origin (which is the intersection of the point normals at the start
      and end points).</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Offsetting a quadratic Bézier curve">
      void setupCurve() {
        setupDefaultQuadratic();
        offsetting();
        offset = 20;
      }

      void drawCurve(BezierCurve curve) {
        additionals();
        curve.draw();
        if(offset>0) {
          noAdditionals();
          BezierCurve[] offsetCurve = curve.offset(offset);
          for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
          offsetCurve = curve.offset(-offset);
          for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
        }
      }</textarea>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Offsetting a cubic Bézier curve">
      void setupCurve() {
        setupDefaultCubic();
        offsetting();
        offset = 20;
      }

      void drawCurve(BezierCurve curve) {
        additionals();
        curve.draw();
        if(offset>0) {
          noAdditionals();
          BezierCurve[] offsetCurve = curve.offset(offset);
          for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
          offsetCurve = curve.offset(-offset);
          for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
        }
      }</textarea>
    </section>

    <section id="graduatedoffset">
      <h2>Graduated curve offsetting</h2>

      <p>What if we want to do graduated offsetting, starting at some distance <i>s</i> but ending
      at some other distance <i>e</i>? well, if we can compute the length of a curve (which we can
      if we use the Legendre-Gauss quadrature approach) then we can also determine how far "along the
      line" any point on the curve is. With that knowledge, we can offset a curve so that its offset
      curve is not uniformly wide, but graduated between with two different offset widths at the
      start and end.</p>

      <p>Like normal offsetting we cut up our curve in subcurves, and then check at which distance
      along the origina curve it starts and ends, and we can see which point on the curve each of
      the control points maps to. This gives us a distance-along-the-curve for each point in the
      curve. If <i>S</i> is the total length of all subcurves up to this curve (or zero, if it's the
      first curve), and <i>L</i> is the length of our original curve, then we get these offset values:</p>

      <ul>
        <li>start: <i>map(S, 0,L, s,e)</i></li>
        <li>c1: <i>map(S+d1, 0,L, s,e)</i>, d1 = distance along curve to projection of c1</li>
        <li>c2: <i>map(S+d2, 0,L, s,e)</i></li>
        <li>...</li>
        <li>end: <i>map(S+length(subcurve), 0,L, d1,d2)</i></li>
      </ul>

      At each of the relevant points (start, end, and the projections of the control points onto
      the curve) we know the curve's normal, so offsetting is simply a matter of taking our original
      point, and moving it along the normal vector by the offset distance for each point. Doing so
      will give us the following result (these have with a starting width of 0, and an end width
      of 40 pixels, but can be controlled with your + and - keys):</p>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Graduated offsetting a quadratic Bézier curve">
      void setupCurve() {
        setupDefaultQuadratic();
        offsetting();
        offset = 20;
      }

      void drawCurve(BezierCurve curve) {
        additionals();
        curve.draw();
        if(offset>0) {
          noAdditionals();
          BezierCurve[] offsetCurve = curve.offset(offset, 0, 1);
          for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
          offsetCurve = curve.offset(-offset, 0, 1);
          for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
        }
      }</textarea>

      <textarea class="sketch-code" data-sketch-preset="simple" data-sketch-title="Graduated offsetting a cubic Bézier curve">
      void setupCurve() {
        setupDefaultCubic();
        offsetting();
        offset = 20;
      }

      void drawCurve(BezierCurve curve) {
        additionals();
        curve.draw();
        if(offset>0) {
          noAdditionals();
          BezierCurve[] offsetCurve = curve.offset(offset, 0, 1);
          for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
          offsetCurve = curve.offset(-offset, 0, 1);
          for(BezierCurve b: offsetCurve) { b.draw(); b.getPoint(0).draw(); b.getPoint(1).draw();}
        }
      }</textarea>
    </section>

    <section id="remaining">
      <h2>Sections that still need to be written</h2>

      <ol>
        <li>Approximating (elliptical?) arcs with Bezier curves</li>
        <li>Approximating Bezier curves with (elliptical?) arcs</li>
        <li>Drawing "dashed" curves (effectively: getting t-for-distance)</li>
      </ol>

      <p>If there's anything missing from this list, plase file an issue on github (link's in the
      upper right corner)</p>
    </section>
  </body>

 <!-- scripts can come last -->
  <script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    displayAlign: "left",
    displayIndent: "2em",
  });</script>
  <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
  <script src="autonav.js"></script>
  <script src="sketchloader.js"></script>
  <script src="processing.patched.js"></script>
</html>
